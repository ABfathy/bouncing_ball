<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <!-- Crucial for responsive design on mobile -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Bouncing Ball Game</title>
    <style>
        /* Basic reset and body styling */
        * {
            box-sizing: border-box; /* Include padding and border in element's total width and height */
        }

        html, body {
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
            overflow: hidden; /* Prevent scrolling */
            background-color: #1c1d21;
            color: #ecf0f1;
            font-family: 'Arial', sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center; /* Center content vertically */
        }

        #start-screen {
            text-align: center;
            padding: 20px; /* Reduced padding for smaller screens */
            background-color: #0b0c10;
            border: 2px solid #2c3e69;
            border-radius: 10px;
            box-shadow: 0 0 15px rgba(75, 108, 183, 0.5);
            max-width: 90%; /* Prevent it from getting too wide */
        }

        #start-screen h1 {
            margin-bottom: 20px; /* Reduced margin */
            color: #61dafb;
            font-size: 1.8em; /* Relative font size */
        }

        #game-area-container {
            display: flex;
            flex-wrap: wrap; /* Allow canvases to wrap on smaller screens */
            justify-content: center;
            align-items: center;
            gap: 15px; /* Space between canvases */
            width: 100%;
            padding: 10px;
            display: none; /* Initially hidden */
            margin-top: 10px; /* Space below buttons */
        }

        canvas {
            background-color: #0b0c10;
            border: 2px solid #2c3e69;
            display: block; /* Prevent extra space below canvas */
            /* Width and height will be set by JS, but max-width prevents overflow */
            max-width: 100%;
            /* max-height needed if height is also dynamic, but keep it fixed for now */
            /* height: auto; */ /* Use if aspect ratio needs preserving with dynamic height */
        }

        .buttons {
            text-align: center;
            display: none; /* Initially hidden */
            width: 100%;
            padding: 5px 0;
        }

        button {
            padding: 10px 20px; /* Slightly smaller buttons */
            margin: 8px;
            font-size: 16px; /* Slightly smaller font */
            font-family: 'Arial', sans-serif;
            background: linear-gradient(145deg, #4b6cb7, #182848);
            border: 1px solid #2c3e69;
            border-radius: 8px;
            color: white;
            cursor: pointer;
            text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.5);
            box-shadow: 3px 3px 6px rgba(0, 0, 0, 0.2), -3px -3px 6px rgba(0, 0, 0, 0.2);
            transition: all 0.3s ease;
            -webkit-tap-highlight-color: transparent; /* Remove tap highlight on mobile */
        }

        button:hover {
            background: linear-gradient(145deg, #5a7ecb, #1e325a);
            transform: translateY(-2px);
            box-shadow: 4px 4px 8px rgba(0, 0, 0, 0.3), -4px -4px 8px rgba(0, 0, 0, 0.3);
        }

        button:active {
            background: linear-gradient(145deg, #3b5572, #121c34);
            transform: translateY(1px);
            box-shadow: inset 2px 2px 4px rgba(0, 0, 0, 0.2), inset -2px -2px 4px rgba(0, 0, 0, 0.2);
        }

        /* Adjust layout for smaller screens */
        @media (max-width: 600px) {
            #start-screen h1 {
                font-size: 1.5em;
            }
            button {
                padding: 8px 15px;
                font-size: 14px;
            }
            #game-area-container {
                gap: 10px;
            }
        }
         @media (max-width: 1100px) and (min-width: 601px) {
             #game-area-container {
                 flex-direction: column; /* Stack canvases vertically on medium screens in 2p mode */
             }
         }
         @media (max-width: 600px) {
             #game-area-container {
                 flex-direction: column; /* Stack canvases vertically on small screens in 2p mode */
             }
         }

    </style>
</head>

<body>

    <div id="start-screen">
        <h1>Bouncing Ball</h1>
        <button onclick="selectGameMode(1)">1 Player</button>
        <button onclick="selectGameMode(2)">2 Players</button>
    </div>

    <div class="buttons">
        <button id="start-button" onclick="startButton()">START / RESUME</button>
        <button id="restart-button" onclick="restartButton()">RESTART / NEW GAME</button>
    </div>

    <div id="game-area-container">
        <!-- Canvases will be added here by JavaScript -->
    </div>

    <script>
        let gameMode = null;
        let gameStarted = false;
        let gameOver = false;
        let animationFrameId = null;

        // --- Canvas 1 Variables ---
        let canvas1, context1;
        let blocks1 = [];
        let paddle1;
        let ball1;
        let score1;
        let scoreValue1 = 0;
        let lives1;
        let livesValue1 = 3;
        let idleText1 = null;
        let winText1 = null;
        let loseText1 = null;
        let ball1Active = false;
        let paddle1Direction = 0; // -1 left, 0 stop, 1 right
        let touch1Identifier = null; // Track touch for player 1
        let player1Respawning = false;
        let respawnTimer1 = null;
        let respawnIntervalId1 = null;


        // --- Canvas 2 Variables ---
        let canvas2, context2;
        let blocks2 = [];
        let paddle2;
        let ball2;
        let score2;
        let scoreValue2 = 0;
        let lives2;
        let livesValue2 = 3;
        let idleText2 = null;
        let winText2 = null;
        let loseText2 = null;
        let ball2Active = false;
        let paddle2Direction = 0; // -1 left, 0 stop, 1 right
        let touch2Identifier = null; // Track touch for player 2
        let player2Respawning = false;
        let respawnTimer2 = null;
        let respawnIntervalId2 = null;


        // --- Constants ---
        const PADDLE_SPEED = 5; // Adjust speed as needed
        const BALL_START_SPEED_Y = 4; // Adjust speed as needed
        const BASE_CANVAS_WIDTH = 520;
        const BASE_CANVAS_HEIGHT = 600; // Keep height fixed for simplicity
        const RESPAWN_DELAY = 3000;

        // --- DOM Elements ---
        const startScreen = document.getElementById('start-screen');
        const gameButtons = document.querySelector('.buttons');
        const gameAreaContainer = document.getElementById('game-area-container');
        const startBtn = document.getElementById('start-button');
        const restartBtn = document.getElementById('restart-button');


        function selectGameMode(mode) {
            gameMode = mode;
            startScreen.style.display = 'none';
            gameButtons.style.display = 'block';
            gameAreaContainer.style.display = 'flex'; // Use flex defined in CSS
            initializeGame(mode);
        }

        function initializeGame(mode) {
            gameAreaContainer.innerHTML = ''; // Clear previous canvases

            // Calculate responsive canvas width
            // Fit two canvases side-by-side if possible, else stack them (handled by CSS flex-wrap/media queries)
            const containerPadding = 20; // Total padding/gap allowance
            const availableWidth = window.innerWidth - containerPadding;
            let canvasWidth = Math.min(BASE_CANVAS_WIDTH, availableWidth / (mode === 2 ? 2 : 1) - (mode === 2 ? 10 : 0)); // Subtract gap if 2 players
            canvasWidth = Math.max(300, canvasWidth); // Minimum width
            const canvasHeight = BASE_CANVAS_HEIGHT; // Keep height fixed for now

            // --- Initialize Player 1 ---
            canvas1 = document.createElement("canvas");
            canvas1.width = canvasWidth;
            canvas1.height = canvasHeight;
            context1 = canvas1.getContext("2d");
            gameAreaContainer.appendChild(canvas1);

            blocks1 = [];
            // Pass canvas dimensions to creation functions
            createBlocks(blocks1, context1, canvasWidth);
            paddle1 = createPaddle(canvas1, context1);
            ball1 = createBall(canvas1, context1, "#61dafb");
            score1 = new ScoreLivesText(10, 23, "16px Arial", "white", "P1 Score: ", context1); // Slightly smaller font
            lives1 = new ScoreLivesText(canvasWidth - 100, 23, "16px Arial", "white", "P1 Lives: ", context1); // Position relative to width
            updateIdleTextPosition(1, canvasWidth, canvasHeight); // Dynamic position


            // --- Initialize Player 2 (if applicable) ---
            if (mode === 2) {
                canvas2 = document.createElement("canvas");
                canvas2.width = canvasWidth;
                canvas2.height = canvasHeight;
                context2 = canvas2.getContext("2d");
                gameAreaContainer.appendChild(canvas2);

                blocks2 = [];
                createBlocks(blocks2, context2, canvasWidth);
                paddle2 = createPaddle(canvas2, context2);
                ball2 = createBall(canvas2, context2, "#ffcc00");
                score2 = new ScoreLivesText(10, 23, "16px Arial", "white", "P2 Score: ", context2);
                lives2 = new ScoreLivesText(canvasWidth - 100, 23, "16px Arial", "white", "P2 Lives: ", context2);
                 updateIdleTextPosition(2, canvasWidth, canvasHeight);
            } else {
                canvas2 = null; // Ensure canvas2 related variables are null in 1P mode
                context2 = null;
                blocks2 = [];
                paddle2 = null;
                ball2 = null;
                score2 = null;
                lives2 = null;
                idleText2 = null;
                winText2 = null;
                loseText2 = null;
            }

            resetGameVariables(); // Reset scores, lives etc.

             // Set initial idle text after variables are reset
            if (canvas1 && !gameStarted && !gameOver) {
                 updateIdleTextPosition(1, canvas1.width, canvas1.height);
                 idleText1 = new ShowText(canvas1.width / 2, canvas1.height / 2 - 50, "18px Arial", "lime", "Click START", context1, true);
            }
             if (gameMode === 2 && canvas2 && !gameStarted && !gameOver) {
                 updateIdleTextPosition(2, canvas2.width, canvas2.height);
                 idleText2 = new ShowText(canvas2.width / 2, canvas2.height / 2 - 50, "18px Arial", "lime", "Click START", context2, true);
             }


            if (!animationFrameId) {
                gameLoop();
            } else {
                // If loop is already running (e.g., restart mid-game), just clear and draw new state
                clearCanvas();
                drawGameElements();
            }
        }

         function resetGameVariables() {
            gameOver = false;
            gameStarted = false; // Reset game started flag
            ball1Active = false;
            player1Respawning = false;
            paddle1Direction = 0;
            touch1Identifier = null; // Reset touch tracking

            scoreValue1 = 0;
            livesValue1 = 3;
            winText1 = null;
            loseText1 = null;
            idleText1 = null; // Reset texts
            respawnTimer1 = null;
            if (respawnIntervalId1) clearInterval(respawnIntervalId1);
            respawnIntervalId1 = null;

             if (ball1) ball1.reset(); // Reset ball position and speed
             if (paddle1 && canvas1) paddle1.x = (canvas1.width - paddle1.width) / 2; // Center paddle


            if (gameMode === 2) {
                ball2Active = false;
                player2Respawning = false;
                paddle2Direction = 0;
                touch2Identifier = null;

                scoreValue2 = 0;
                livesValue2 = 3;
                winText2 = null;
                loseText2 = null;
                idleText2 = null;
                respawnTimer2 = null;
                if (respawnIntervalId2) clearInterval(respawnIntervalId2);
                respawnIntervalId2 = null;

                 if (ball2) ball2.reset();
                 if (paddle2 && canvas2) paddle2.x = (canvas2.width - paddle2.width) / 2; // Center paddle
            }

             // Re-create idle text if canvases exist and game not started/over
             updateIdleTextPosition(1); // Update positions based on current canvas size
             updateIdleTextPosition(2);
        }

        // Function to update text positions based on canvas size
        function updateTextPosition(textObj, canvasW, canvasH, centered = false) {
            if (!textObj) return;
            textObj.x = centered ? canvasW / 2 : textObj.initialX || 10; // Use initialX if defined, else default
            textObj.y = centered ? canvasH / 2 : textObj.initialY || 23; // Use initialY if defined, else default
            if (centered) {
                // Adjust for text width if centering is needed more accurately (optional)
                // let metrics = textObj.context.measureText(textObj.text);
                // textObj.x -= metrics.width / 2;
            }
             if (textObj.label && textObj.label.includes("Lives")) { // Special case for Lives text positioning
                 textObj.x = canvasW - 100; // Position from right
             }
        }

        // Helper to update standard text positions
        function updateIdleTextPosition(playerIndex, canvasW, canvasH) {
             if (!canvasW || !canvasH) { // Get dimensions if not passed
                 const canvas = playerIndex === 1 ? canvas1 : canvas2;
                 if (!canvas) return;
                 canvasW = canvas.width;
                 canvasH = canvas.height;
             }
            const textProps = { font: "18px Arial", color: "lime", centered: true }; // Common props
            if (playerIndex === 1) {
                 if (idleText1) updateTextPosition(idleText1, canvasW, canvasH, textProps.centered);
                 if (winText1) updateTextPosition(winText1, canvasW, canvasH, textProps.centered);
                 if (loseText1) updateTextPosition(loseText1, canvasW, canvasH, textProps.centered);
                 if (respawnTimer1) updateTextPosition(respawnTimer1, canvasW, canvasH, textProps.centered);
            } else if (playerIndex === 2) {
                 if (idleText2) updateTextPosition(idleText2, canvasW, canvasH, textProps.centered);
                 if (winText2) updateTextPosition(winText2, canvasW, canvasH, textProps.centered);
                 if (loseText2) updateTextPosition(loseText2, canvasW, canvasH, textProps.centered);
                 if (respawnTimer2) updateTextPosition(respawnTimer2, canvasW, canvasH, textProps.centered);
            }
        }


         // Modify createBlocks to potentially scale/adjust based on width (simplified version)
        function createBlocks(blockArray, ctx, canvasWidth) {
            blockArray.length = 0;
            // Keep block size fixed, adjust offsets/counts if needed for smaller canvasWidth
            const blockWidth = 60 * (canvasWidth / BASE_CANVAS_WIDTH); // Scale block width
            const blockHeight = 20;
            const padding = 10 * (canvasWidth / BASE_CANVAS_WIDTH); // Scale padding
            const blockRowCount = 5;
            // Adjust column count based on available width
            const availableBlockArea = canvasWidth - (padding * 2);
            const blockColCount = Math.min(7, Math.floor(availableBlockArea / (blockWidth + padding)));

            const totalBlockWidth = blockColCount * (blockWidth + padding) - padding;
            const offsetLeft = (canvasWidth - totalBlockWidth) / 2; // Center the blocks
            const offsetTop = 35;

            const colors = ["#e74c3c", "#f39c12", "#f1c40f", "#2ecc71", "#3498db"];

            for (let row = 0; row < blockRowCount; row++) {
                for (let col = 0; col < blockColCount; col++) {
                    const x = offsetLeft + col * (blockWidth + padding);
                    const y = offsetTop + row * (blockHeight + padding);
                    const color = colors[row % colors.length];
                    // Pass context only, remove canvas from here
                    const block = new DrawBlockPaddle(blockWidth, blockHeight, color, x, y, ctx);
                    blockArray.push(block);
                }
            }
        }

        // createPaddle uses canvas passed to it
        function createPaddle(canvas, ctx) {
            const paddleWidth = 100 * (canvas.width / BASE_CANVAS_WIDTH); // Scale paddle width
            const paddleHeight = 15;
            let paddleX = (canvas.width - paddleWidth) / 2; // Center based on actual canvas width
            let paddleY = canvas.height - paddleHeight - 10;
            return new DrawBlockPaddle(paddleWidth, paddleHeight, "lightgrey", paddleX, paddleY, ctx);
        }

        // createBall uses canvas passed to it
        function createBall(canvas, ctx, color) {
            let ballRadius = 10 * (canvas.width / BASE_CANVAS_WIDTH); // Scale ball radius slightly
            ballRadius = Math.max(6, ballRadius); // Minimum radius
            let ballX = canvas.width / 2;
            let ballY = canvas.height / 2 + 50;
            return new DrawBall(ballX, ballY, ballRadius, color, ctx, canvas);
        }

        // --- Object Constructors (Modified slightly for clarity/consistency) ---

        function DrawBlockPaddle(width, height, color, x, y, context) {
            this.width = width;
            this.height = height;
            this.x = x;
            this.y = y;
            this.context = context;
            this.color = color;

            this.update = function () {
                this.context.fillStyle = this.color;
                this.context.fillRect(this.x, this.y, this.width, this.height);
            }
        }

        function DrawBall(x, y, r, color, context, canvas) {
            this.initialX = x; // Store initial positions based on current canvas size
            this.initialY = y;
            this.x = x;
            this.y = y;
            this.r = r;
            this.color = color;
            this.speedX = 0;
            this.speedY = 0;
            this.context = context;
            this.canvas = canvas; // Keep reference to own canvas

            this.update = function () {
                this.context.fillStyle = this.color;
                this.context.beginPath();
                this.context.arc(this.x, this.y, this.r, 0, 2 * Math.PI);
                this.context.fill();
                this.context.closePath();
            }

            this.reset = function() {
                 // Reset to initial positions calculated for the *current* canvas size
                this.x = this.canvas.width / 2;
                this.y = this.initialY; // Use initial Y, X is centered
                this.speedX = 0;
                this.speedY = 0;
            }
        }

        function ScoreLivesText(x, y, font, color, label, context) {
            this.initialX = x; // Store initial X for potential repositioning
            this.initialY = y; // Store initial Y
            this.x = x;
            this.y = y;
            this.font = font;
            this.color = color;
            this.label = label;
            this.context = context;
            this.value = 0; // Value is dynamic

            this.update = function () {
                this.context.font = this.font;
                this.context.fillStyle = this.color;
                this.context.fillText(this.label + this.value, this.x, this.y);
            }
        }

        function ShowText(x, y, font, color, text, context, centered = false) {
            this.initialX = x; // Store initial positions
            this.initialY = y;
            this.x = x;
            this.y = y;
            this.font = font;
            this.color = color;
            this.text = text; // Text can change (like respawn timer)
            this.context = context;
            this.centered = centered; // Flag for centering logic

            this.update = function () {
                this.context.font = this.font;
                this.context.fillStyle = this.color;
                let drawX = this.x;
                // Simple centering based on flag
                if (this.centered) {
                    this.context.textAlign = "center";
                    drawX = this.context.canvas.width / 2; // Use canvas width for centering
                } else {
                    this.context.textAlign = "left";
                }
                this.context.fillText(this.text, drawX, this.y);
                this.context.textAlign = "left"; // Reset alignment
            }
        }


        function gameLoop() {
            if (gameOver) {
                // Still draw the final state (win/lose messages) even if game over
                drawGameElements();
                 // Don't request another frame if game is truly over and shouldn't update
                 // animationFrameId = null; // Clear ID if stopping completely
                return;
            }
            updateGameArea();
            drawGameElements();
            animationFrameId = requestAnimationFrame(gameLoop);
        }

        function clearCanvas() {
             if (context1) context1.clearRect(0, 0, canvas1.width, canvas1.height);
             if (context2) context2.clearRect(0, 0, canvas2.width, canvas2.height);
        }

        function updateGameArea() {
            // Player 1 Update Logic
            if (canvas1 && paddle1) {
                // Paddle Movement: Apply direction * speed, constrained by canvas bounds
                paddle1.x += paddle1Direction * PADDLE_SPEED;
                paddle1.x = Math.max(0, Math.min(paddle1.x, canvas1.width - paddle1.width)); // Use dynamic canvas width

                // Ball Movement & Logic
                if (ball1Active && !player1Respawning) {
                    ball1.x += ball1.speedX;
                    ball1.y += ball1.speedY;
                    ballHitDetection(ball1, paddle1, blocks1, 1);
                } else if (!ball1Active && livesValue1 > 0 && gameStarted && !player1Respawning && !gameOver) {
                    // Ball attached to paddle before launch/after respawn
                    ball1.x = paddle1.x + paddle1.width / 2;
                    ball1.y = paddle1.y - ball1.r - 2; // Position above paddle center
                }

                // Update Score/Lives display objects
                if (score1) score1.value = scoreValue1;
                if (lives1) lives1.value = livesValue1;
            }

            // Player 2 Update Logic (only if mode is 2)
            if (gameMode === 2 && canvas2 && paddle2) {
                paddle2.x += paddle2Direction * PADDLE_SPEED;
                paddle2.x = Math.max(0, Math.min(paddle2.x, canvas2.width - paddle2.width)); // Use dynamic canvas width

                if (ball2Active && !player2Respawning) {
                    ball2.x += ball2.speedX;
                    ball2.y += ball2.speedY;
                    ballHitDetection(ball2, paddle2, blocks2, 2);
                 } else if (!ball2Active && livesValue2 > 0 && gameStarted && !player2Respawning && !gameOver) {
                    ball2.x = paddle2.x + paddle2.width / 2;
                    ball2.y = paddle2.y - ball2.r - 2;
                }

                if (score2) score2.value = scoreValue2;
                if (lives2) lives2.value = livesValue2;
            }
        }


        function drawGameElements() {
            clearCanvas(); // Clear both canvases first

            // Draw Player 1 Elements
            if (canvas1) {
                blocks1.forEach(block => block.update());
                if(paddle1) paddle1.update();
                if(ball1) ball1.update();
                if(score1) score1.update();
                if(lives1) lives1.update();
                if (idleText1) idleText1.update();
                if (winText1) winText1.update();
                if (loseText1) loseText1.update();
                if (respawnTimer1) respawnTimer1.update();
            }

            // Draw Player 2 Elements
            if (gameMode === 2 && canvas2) {
                blocks2.forEach(block => block.update());
                 if(paddle2) paddle2.update();
                 if(ball2) ball2.update();
                 if(score2) score2.update();
                 if(lives2) lives2.update();
                if (idleText2) idleText2.update();
                if (winText2) winText2.update();
                if (loseText2) loseText2.update();
                if (respawnTimer2) respawnTimer2.update();
            }
        }

        function startButton() {
            if (gameOver) return; // Don't start if game is over

            if (!gameStarted) {
                gameStarted = true;
                idleText1 = null; // Remove initial prompt text
                 if (gameMode === 2) idleText2 = null;
                 addInputListeners(); // Add listeners only when game actually starts
            }

             // Launch ball for Player 1 if ready
             if (canvas1 && livesValue1 > 0 && !ball1Active && !player1Respawning) {
                 ball1Active = true;
                 ball1.speedY = -BALL_START_SPEED_Y; // Start moving up
                 ball1.speedX = (Math.random() - 0.5) * 4; // Random horizontal start direction
             }
             // Launch ball for Player 2 if ready
             if (gameMode === 2 && canvas2 && livesValue2 > 0 && !ball2Active && !player2Respawning) {
                 ball2Active = true;
                 ball2.speedY = -BALL_START_SPEED_Y;
                 ball2.speedX = (Math.random() - 0.5) * 4;
             }
        }

        function addInputListeners() {
            // Keyboard listeners
            document.addEventListener("keydown", handleKeyDown);
            document.addEventListener("keyup", handleKeyUp);

            // Touch listeners (add to canvases)
            if (canvas1) {
                canvas1.addEventListener("touchstart", handleTouchStart, { passive: false }); // Use passive: false to allow preventDefault
                canvas1.addEventListener("touchmove", handleTouchMove, { passive: false });
                canvas1.addEventListener("touchend", handleTouchEnd);
                canvas1.addEventListener("touchcancel", handleTouchEnd); // Treat cancel like end
            }
            if (gameMode === 2 && canvas2) {
                canvas2.addEventListener("touchstart", handleTouchStart, { passive: false });
                canvas2.addEventListener("touchmove", handleTouchMove, { passive: false });
                canvas2.addEventListener("touchend", handleTouchEnd);
                canvas2.addEventListener("touchcancel", handleTouchEnd);
            }
        }

        function removeInputListeners() {
            // Keyboard listeners
            document.removeEventListener("keydown", handleKeyDown);
            document.removeEventListener("keyup", handleKeyUp);

            // Touch listeners
             if (canvas1) {
                canvas1.removeEventListener("touchstart", handleTouchStart);
                canvas1.removeEventListener("touchmove", handleTouchMove);
                canvas1.removeEventListener("touchend", handleTouchEnd);
                canvas1.removeEventListener("touchcancel", handleTouchEnd);
            }
            if (gameMode === 2 && canvas2) {
                canvas2.removeEventListener("touchstart", handleTouchStart);
                canvas2.removeEventListener("touchmove", handleTouchMove);
                canvas2.removeEventListener("touchend", handleTouchEnd);
                canvas2.removeEventListener("touchcancel", handleTouchEnd);
            }

            // Reset paddle directions and touch tracking on removal
            paddle1Direction = 0;
            paddle2Direction = 0;
            touch1Identifier = null;
            touch2Identifier = null;
        }

        // --- Keyboard Handlers ---
        function handleKeyDown(e) {
             if (gameOver || !gameStarted) return;

             // Player 1 (Arrows)
            if (e.keyCode === 37) { // Left Arrow
                 paddle1Direction = -1;
                 e.preventDefault(); // Prevent window scrolling
             }
            else if (e.keyCode === 39) { // Right Arrow
                 paddle1Direction = 1;
                 e.preventDefault();
             }

            // Player 2 (A/D) - only if mode is 2
            if (gameMode === 2) {
                if (e.key === 'a' || e.key === 'A') {
                    paddle2Direction = -1;
                    e.preventDefault();
                } else if (e.key === 'd' || e.key === 'D') {
                    paddle2Direction = 1;
                    e.preventDefault();
                }
            }
        }

        function handleKeyUp(e) {
            if (gameOver || !gameStarted) return;

            // Player 1
            if (e.keyCode === 37 && paddle1Direction === -1) { // Check current direction before stopping
                paddle1Direction = 0;
            } else if (e.keyCode === 39 && paddle1Direction === 1) {
                paddle1Direction = 0;
            }

            // Player 2
            if (gameMode === 2) {
                if ((e.key === 'a' || e.key === 'A') && paddle2Direction === -1) {
                    paddle2Direction = 0;
                } else if ((e.key === 'd' || e.key === 'D') && paddle2Direction === 1) {
                    paddle2Direction = 0;
                }
            }
        }

        // --- Touch Handlers ---
        function handleTouchStart(e) {
            if (gameOver || !gameStarted) return;
            e.preventDefault(); // IMPORTANT: Prevent scrolling/zooming etc.
            const touches = e.changedTouches; // Use changedTouches for multi-touch safety

            for (let i = 0; i < touches.length; i++) {
                const touch = touches[i];
                const targetCanvas = e.target; // The canvas that was touched

                // Determine touch position relative to the canvas
                const rect = targetCanvas.getBoundingClientRect();
                const touchX = touch.clientX - rect.left;
                // const touchY = touch.clientY - rect.top; // Y not needed for horizontal movement

                if (targetCanvas === canvas1) {
                     // Only track one touch per paddle
                     if (touch1Identifier === null) {
                         touch1Identifier = touch.identifier; // Store the ID of the touch controlling P1
                         // Set direction based on which half of the canvas was touched
                         paddle1Direction = (touchX < targetCanvas.width / 2) ? -1 : 1;
                     }
                 } else if (gameMode === 2 && targetCanvas === canvas2) {
                     if (touch2Identifier === null) {
                         touch2Identifier = touch.identifier;
                         paddle2Direction = (touchX < targetCanvas.width / 2) ? -1 : 1;
                     }
                 }
            }
        }

        function handleTouchMove(e) {
             if (gameOver || !gameStarted) return;
             e.preventDefault();
             const touches = e.changedTouches;

             for (let i = 0; i < touches.length; i++) {
                 const touch = touches[i];
                 const targetCanvas = e.target;

                 const rect = targetCanvas.getBoundingClientRect();
                 const touchX = touch.clientX - rect.left;

                 // Update direction only if this touch is the one controlling the paddle
                 if (targetCanvas === canvas1 && touch.identifier === touch1Identifier) {
                     paddle1Direction = (touchX < targetCanvas.width / 2) ? -1 : 1;
                 } else if (gameMode === 2 && targetCanvas === canvas2 && touch.identifier === touch2Identifier) {
                     paddle2Direction = (touchX < targetCanvas.width / 2) ? -1 : 1;
                 }
             }
        }

        function handleTouchEnd(e) {
             if (gameOver || !gameStarted) return;
             // Don't preventDefault here, allows other elements to be interacted with after
             const touches = e.changedTouches;

             for (let i = 0; i < touches.length; i++) {
                 const touch = touches[i];
                 const targetCanvas = e.target;

                 // If the touch that ended was controlling a paddle, stop that paddle
                 if (targetCanvas === canvas1 && touch.identifier === touch1Identifier) {
                     paddle1Direction = 0;
                     touch1Identifier = null; // Release the identifier
                 } else if (gameMode === 2 && targetCanvas === canvas2 && touch.identifier === touch2Identifier) {
                     paddle2Direction = 0;
                     touch2Identifier = null;
                 }
             }
        }


        function ballHitDetection(ball, paddle, blocks, playerIndex) {
             if (gameOver || !ball) return; // Extra safety checks

            const ballTop = ball.y - ball.r;
            const ballBottom = ball.y + ball.r;
            const ballRight = ball.x + ball.r;
            const ballLeft = ball.x - ball.r;

            // Use the ball's own canvas reference for boundaries
             const canvas = ball.canvas;
             if (!canvas) return; // Safety check

            // --- Wall Collisions ---
            // Left/Right Walls
            if (ballLeft <= 0) {
                 ball.speedX = Math.abs(ball.speedX); // Ensure positive speedX
                 ball.x = ball.r; // Prevent sticking
             } else if (ballRight >= canvas.width) {
                 ball.speedX = -Math.abs(ball.speedX); // Ensure negative speedX
                 ball.x = canvas.width - ball.r; // Prevent sticking
             }
            // Top Wall
            if (ballTop <= 0) {
                ball.speedY = Math.abs(ball.speedY); // Ensure positive speedY
                ball.y = ball.r; // Prevent sticking
            }

            // --- Paddle Collision ---
            // Check if ball is moving down and potentially hitting the paddle top
            if (ball.speedY > 0 && // Moving down
                ballBottom >= paddle.y && // Ball base is at or below paddle top
                ballTop <= paddle.y + paddle.height && // Ball top is above paddle bottom
                ballRight >= paddle.x && // Ball right edge is past paddle left edge
                ballLeft <= paddle.x + paddle.width) // Ball left edge is before paddle right edge
             {
                 // Calculate hit position relative to paddle center (-1 to 1)
                 let hitPosition = (ball.x - (paddle.x + paddle.width / 2)) / (paddle.width / 2);
                 hitPosition = Math.max(-0.95, Math.min(0.95, hitPosition)); // Clamp to avoid extreme angles

                 // Calculate bounce angle (e.g., up to 75 degrees off vertical)
                 const maxBounceAngle = (75 * Math.PI) / 180;
                 const bounceAngle = hitPosition * maxBounceAngle;

                 // Maintain ball speed (or adjust if desired)
                 const currentSpeed = Math.sqrt(ball.speedX ** 2 + ball.speedY ** 2);
                 const newSpeedY = -Math.abs(currentSpeed * Math.cos(bounceAngle)); // Always bounce upwards
                 const newSpeedX = currentSpeed * Math.sin(bounceAngle);

                 ball.speedX = newSpeedX;
                 ball.speedY = newSpeedY;
                 ball.y = paddle.y - ball.r; // Place ball just above paddle to prevent sticking
            }

            // --- Block Collisions ---
            for (let i = blocks.length - 1; i >= 0; i--) {
                let block = blocks[i];
                // Simple Axis-Aligned Bounding Box (AABB) collision check
                if (ballRight > block.x &&
                    ballLeft < block.x + block.width &&
                    ballBottom > block.y &&
                    ballTop < block.y + block.height)
                {
                     // Determine collision side (basic approach: check overlap amount)
                     // More robust check would involve previous position, but simple reflection is often ok
                     const overlapX = Math.min(ballRight - block.x, block.x + block.width - ballLeft);
                     const overlapY = Math.min(ballBottom - block.y, block.y + block.height - ballTop);

                     if (overlapY <= overlapX) { // Primarily vertical collision
                        ball.speedY *= -1;
                        // Nudge ball out vertically
                        ball.y += (ball.speedY > 0 ? 1 : -1);
                    } else { // Primarily horizontal collision
                        ball.speedX *= -1;
                         // Nudge ball out horizontally
                         ball.x += (ball.speedX > 0 ? 1 : -1);
                     }

                    // Increment score based on player index
                    if (playerIndex === 1) scoreValue1++;
                    else if (playerIndex === 2) scoreValue2++;

                    // Remove the hit block
                    blocks.splice(i, 1);

                    // Check for win condition (no blocks left)
                    if (blocks.length === 0) {
                        handleWin(playerIndex);
                        return; // Stop further collision checks for this frame
                    }
                    break; // Assume only one block hit per frame
                }
            }

             // --- Bottom Boundary (Lose Life) ---
             if (ballBottom > canvas.height) {
                handleLifeLost(playerIndex);
             }
        }


         function handleLifeLost(playerIndex) {
             if (gameOver) return; // Don't lose life if game already over

            if (playerIndex === 1) {
                 livesValue1--;
                 ball1Active = false;
                 if (ball1) ball1.reset(); // Reset ball position/speed

                if (livesValue1 <= 0) {
                     // Player 1 loses. If 1P mode, game over. If 2P mode, Player 2 wins.
                     handleGameOver(gameMode === 1 ? 0 : 2); // 0 for single player loss, 2 for P2 win
                 } else if (!gameOver) { // If lives remain and game not over
                     if (gameMode === 2) {
                         startRespawnTimer(1); // Start respawn timer in 2P
                     } else {
                         // In 1P, show prompt to click start again
                         updateIdleTextPosition(1, canvas1.width, canvas1.height); // Recalc position
                         idleText1 = new ShowText(canvas1.width / 2, canvas1.height / 2 - 50, "18px Arial", "orange", "Lost life! Click START", context1, true);
                         // Need to draw this state
                          drawGameElements();
                     }
                 }
             } else if (playerIndex === 2 && gameMode === 2) { // Only handle P2 if in 2P mode
                 livesValue2--;
                 ball2Active = false;
                 if (ball2) ball2.reset();

                if (livesValue2 <= 0) {
                     handleGameOver(1); // Player 1 wins
                 } else if (!gameOver) {
                     startRespawnTimer(2); // Start respawn timer for P2
                 }
             }
         }

        function startRespawnTimer(playerIndex) {
            if (gameOver) return;

            const canvas = playerIndex === 1 ? canvas1 : canvas2;
            const context = playerIndex === 1 ? context1 : context2;
            if (!canvas || !context) return;

            if (playerIndex === 1) {
                 if (player1Respawning) return; // Already respawning
                 player1Respawning = true;
                 let countdown = 3;
                 updateIdleTextPosition(1, canvas.width, canvas.height); // Center respawn text
                 respawnTimer1 = new ShowText(canvas.width / 2, canvas.height / 2, "24px Arial", "orange", `P1 Respawn: ${countdown}`, context, true);

                if (respawnIntervalId1) clearInterval(respawnIntervalId1); // Clear previous interval just in case

                respawnIntervalId1 = setInterval(() => {
                     if (gameOver) { // Stop timer if game ends during respawn
                          clearInterval(respawnIntervalId1); respawnIntervalId1 = null;
                          respawnTimer1 = null; player1Respawning = false; return;
                     }
                     countdown--;
                     if (countdown > 0) {
                         respawnTimer1.text = `P1 Respawn: ${countdown}`;
                     } else {
                         clearInterval(respawnIntervalId1); respawnIntervalId1 = null;
                         respawnTimer1 = null;
                         player1Respawning = false;
                         // Automatically launch ball after respawn delay if game is running
                         if (!gameOver && gameStarted && livesValue1 > 0) {
                              ball1Active = true;
                              if (ball1) { // Ensure ball exists
                                 ball1.speedY = -BALL_START_SPEED_Y;
                                 ball1.speedX = (Math.random() - 0.5) * 4;
                              }
                         }
                     }
                 }, 1000); // Update every second
             } else { // Player 2
                 if (player2Respawning) return;
                 player2Respawning = true;
                 let countdown = 3;
                  updateIdleTextPosition(2, canvas.width, canvas.height);
                 respawnTimer2 = new ShowText(canvas.width / 2, canvas.height / 2, "24px Arial", "orange", `P2 Respawn: ${countdown}`, context, true);

                if (respawnIntervalId2) clearInterval(respawnIntervalId2);

                respawnIntervalId2 = setInterval(() => {
                    if (gameOver) {
                        clearInterval(respawnIntervalId2); respawnIntervalId2 = null;
                        respawnTimer2 = null; player2Respawning = false; return;
                    }
                    countdown--;
                    if (countdown > 0) {
                        respawnTimer2.text = `P2 Respawn: ${countdown}`;
                    } else {
                        clearInterval(respawnIntervalId2); respawnIntervalId2 = null;
                        respawnTimer2 = null;
                        player2Respawning = false;
                         if (!gameOver && gameStarted && livesValue2 > 0) {
                             ball2Active = true;
                              if (ball2) {
                                 ball2.speedY = -BALL_START_SPEED_Y;
                                 ball2.speedX = (Math.random() - 0.5) * 4;
                              }
                         }
                    }
                }, 1000);
            }
        }

        function handleWin(winningPlayerIndex) {
            if (gameOver) return; // Don't process win if already over

             // Define win/lose text properties
             const textProps = { font: "24px Arial", centered: true };

             if (winningPlayerIndex === 1) {
                 updateIdleTextPosition(1, canvas1.width, canvas1.height);
                 winText1 = new ShowText(canvas1.width / 2, canvas1.height / 2, textProps.font, "lime", "PLAYER 1 WINS!", context1, textProps.centered);
                  if (gameMode === 2 && context2) { // If 2P, show lose text for P2
                      updateIdleTextPosition(2, canvas2.width, canvas2.height);
                      loseText2 = new ShowText(canvas2.width / 2, canvas2.height / 2, textProps.font, "red", "PLAYER 2 LOST!", context2, textProps.centered);
                  }
              } else if (winningPlayerIndex === 2 && gameMode === 2) { // P2 wins (only in 2P mode)
                  updateIdleTextPosition(2, canvas2.width, canvas2.height);
                  winText2 = new ShowText(canvas2.width / 2, canvas2.height / 2, textProps.font, "lime", "PLAYER 2 WINS!", context2, textProps.centered);
                  updateIdleTextPosition(1, canvas1.width, canvas1.height);
                  loseText1 = new ShowText(canvas1.width / 2, canvas1.height / 2, textProps.font, "red", "PLAYER 1 LOST!", context1, textProps.centered);
              }
              endGame();
         }

        function handleGameOver(winningPlayerIndex) { // winningPlayerIndex: 0=1P loss, 1=P1 wins, 2=P2 wins
            if (gameOver) return;

             const textProps = { font: "24px Arial", centered: true };

            if (winningPlayerIndex === 1) { // Player 1 wins (e.g., P2 ran out of lives)
                updateIdleTextPosition(1, canvas1.width, canvas1.height);
                winText1 = new ShowText(canvas1.width / 2, canvas1.height / 2, textProps.font, "lime", "PLAYER 1 WINS!", context1, textProps.centered);
                 if (context2) {
                     updateIdleTextPosition(2, canvas2.width, canvas2.height);
                     loseText2 = new ShowText(canvas2.width / 2, canvas2.height / 2, textProps.font, "red", "PLAYER 2 LOST!", context2, textProps.centered);
                 }
             } else if (winningPlayerIndex === 2) { // Player 2 wins (e.g., P1 ran out of lives)
                 if (context2) {
                     updateIdleTextPosition(2, canvas2.width, canvas2.height);
                     winText2 = new ShowText(canvas2.width / 2, canvas2.height / 2, textProps.font, "lime", "PLAYER 2 WINS!", context2, textProps.centered);
                 }
                  updateIdleTextPosition(1, canvas1.width, canvas1.height);
                 loseText1 = new ShowText(canvas1.width / 2, canvas1.height / 2, textProps.font, "red", "PLAYER 1 LOST!", context1, textProps.centered);
             } else { // Single player game over (winningPlayerIndex === 0)
                 updateIdleTextPosition(1, canvas1.width, canvas1.height);
                  loseText1 = new ShowText(canvas1.width / 2, canvas1.height / 2, textProps.font, "red", "GAME OVER!", context1, textProps.centered);
             }
             endGame();
         }


        function endGame() {
             if (gameOver) return; // Prevent running multiple times
             console.log("Game Ending");
             gameOver = true;
             gameStarted = false; // Game is no longer actively running
             ball1Active = false;
             ball2Active = false;

             // Stop ball movement
             if (ball1) { ball1.speedX = 0; ball1.speedY = 0; }
             if (ball2) { ball2.speedX = 0; ball2.speedY = 0; }

             // Stop timers
             if (respawnIntervalId1) { clearInterval(respawnIntervalId1); respawnIntervalId1 = null; }
             if (respawnIntervalId2) { clearInterval(respawnIntervalId2); respawnIntervalId2 = null; }
             respawnTimer1 = null; // Clear timer text objects
             respawnTimer2 = null;
             player1Respawning = false; // Ensure respawn state is cleared
             player2Respawning = false;

             // Remove input listeners to prevent paddle movement after game over
             removeInputListeners();

              // Ensure the final state is drawn
              drawGameElements();

             // Optional: Cancel the next animation frame if needed, although letting it run once more to draw is fine.
             // if (animationFrameId) {
             //     cancelAnimationFrame(animationFrameId);
             //     animationFrameId = null;
             // }
        }

        function restartButton() {
             console.log("Restarting Game / New Game");
            // Stop the game loop
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }

            // Clean up any ongoing processes
            removeInputListeners(); // Remove keyboard/touch listeners
            if (respawnIntervalId1) clearInterval(respawnIntervalId1);
            if (respawnIntervalId2) clearInterval(respawnIntervalId2);
            respawnIntervalId1 = null;
            respawnIntervalId2 = null;

            // Reset all game state variables (important!)
            // resetGameVariables(); // Call this AFTER resetting mode and hiding elements

            // Hide game elements, show start screen
            gameAreaContainer.style.display = 'none';
            gameAreaContainer.innerHTML = ''; // Clear canvases from DOM
            gameButtons.style.display = 'none';
            startScreen.style.display = 'block';

            // Reset variables tied to specific game instances
            canvas1 = null; context1 = null; blocks1 = []; paddle1 = null; ball1 = null; score1 = null; lives1 = null;
            canvas2 = null; context2 = null; blocks2 = []; paddle2 = null; ball2 = null; score2 = null; lives2 = null;

            // Reset control flags
            gameMode = null; // Ready for new selection
            gameStarted = false;
            gameOver = false;
            // No need to call resetGameVariables here as we are nuking everything
        }

         // Optional: Add a resize listener to re-initialize the game layout if the window size changes drastically
         let resizeTimeout;
         window.addEventListener('resize', () => {
             // Debounce resize event to avoid rapid re-initialization
             clearTimeout(resizeTimeout);
             resizeTimeout = setTimeout(() => {
                 // Only re-initialize if a game mode has been selected (i.e., not on start screen)
                 if (gameMode !== null) {
                     console.log("Window resized, re-initializing layout...");
                     // Re-select the current game mode to redraw with new dimensions
                     // This will stop the current game and start fresh with the mode
                     const currentMode = gameMode;
                     restartButton(); // Clean up current game fully
                     selectGameMode(currentMode); // Start new game with same mode
                 }
             }, 250); // Wait 250ms after last resize event
         });


    </script>
</body>

</html>